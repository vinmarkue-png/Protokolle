\documentclass[a4paper,11pt]{scrartcl} 
\usepackage{geometry} 
\geometry{left=2.5cm} \geometry{top=3cm}

\usepackage[utf8]{inputenc} 
\usepackage[ngerman]{babel} 
\usepackage[T1]{fontenc} 
\usepackage{amsmath} 
\usepackage{amssymb} 
\usepackage[onehalfspacing]{setspace} 
\usepackage{graphicx} 
\usepackage{epstopdf} 
\usepackage{csquotes} 
\usepackage{array} 
\usepackage{upgreek} 
\usepackage{float} 
\usepackage{tikz} 
\usepackage[font=small]{caption}
\usepackage[backend=biber, style=chem-angew]{biblatex} 
\addbibresource{Blatt 7.bib} 
\usepackage{tabularx, booktabs, multirow} 
\usepackage{listings}
\usepackage{chemgreek}
\usepackage{chemformula}
\captionsetup{format=plain}
%\usepackage{hyperref}
\usepackage[hidelinks]{hyperref}
\usepackage{siunitx}
\sisetup{detect-weight=true, detect-family=true,locale=DE,range-phrase={\,bis\,},list-final-separator ={\,\linebreak[0] \text{und}\,},separate-uncertainty=true,per-mode = symbol-or-fraction}

\parindent0pt %Kein Einzug am Anfang von Absätzen
\sloppy %Besserer Blocksatz
%\renewcaptionname{ngerman}{\figurename}{Abb.} 
%\renewcaptionname{ngerman}{\tablename}{Tab.} 
\setkomafont{section}{\normalsize}

\lstset{
    language=Python,
    numbers=left,
    numberstyle=\tiny\color{gray},
    numbersep=8pt,
    stepnumber=1,
    frame=single,
    tabsize=4,
    showstringspaces=false,
    breaklines=true,
    keywordstyle=\color{blue}\bfseries,
    stringstyle=\color{red},
    commentstyle=\color{green!50!black},
    basicstyle=\ttfamily\small,
    literate={ö}{{\"o}}1
             {ä}{{\"a}}1
             {ü}{{\"u}}1
             {ß}{{\ss}}1
}

\title{Blatt 13}
\author{Vincent Kümmerle und Elvis Gnaglo}
\date{\today}

\begin{document}

\maketitle

\section{Berechnung der Eulerschen Zahl}

\begin{lstlisting}
#include <iostream>
#include <iomanip>
// 1. for-Schleife zur Berechnung der Fakultaet k!
long fakultaet(int k) {
    long result = 1; // long, da mit 64-Bit mehr Platz fuer groessere Zahlen
    for (int i = 1; i <= k; ++i) {
        result *= i;}
    return result;
}
// Funktion zur Annaeherung von e durch n Terme
double approximate_e(int n) {
    double summe = 0.0; // double, da Bruchzahlen mit bis zu 16 Nachkommastellen
    for (int k = 0; k < n; ++k) {
        // 2. Berechnung: 1 / k!
        summe += 1.0 / fakultaet(k);}
    return summe;
}
int main() {
    int iterationen = 12;
    // Berechne e
    double e_approx = approximate_e(iterationen);

    // 4. Ausgabe des Ergebnisses
    std::cout << "Annaeherung von e nach " << iterationen << " Iterationen:" << std::endl;
    std::cout << std::fixed << std::setprecision(8) << e_approx << std::endl;
    return 0;
} // Ausgabe: 2.71828183
\end{lstlisting}
% \begin{figure}[H]
%     \centering
%     \includegraphics[width=0.8\textwidth]{Reisender1.pdf}    
%     \caption{Plot einer zufälligen Reisestrecke} 
% \end{figure}


\section{Vektoren I}

\begin{lstlisting}
#include <iostream>
#include <vector>

double sum_below_limit(const std::vector<double>& vector, double limit) {
    double sum = 0.0;
    for (double element : vector) {
        if (element < limit) {
            sum += element;
        }
    }
    return   sum;
}

int main()
{
    std::vector<double> v = { 1.0, 2.0, 3.0, 4.0, 5.0, 42.0, 100.00, 300.00 };
    std::cout << sum_below_limit(v, 4.0) << "\n";
    return 0;
}
\end{lstlisting}

\section{Vektoren II}

\begin{lstlisting}
#include <iostream>
#include <vector>

double scalar_product(const std::vector<double>& vector1,
    const std::vector<double>& vector2) {
    double sum = 0.0;

    for (size_t i = 0; i < vector1.size(); ++i) {
        sum += vector1[i] * vector2[i];
    }

    return sum;
}

int main()
{
    std::vector<double> v1 = { 1.0, 2.0, 3.0, 4.0 };
    std::vector<double> v2 = { 1.0, -1.0, -1.0, 1.0 };
    std::cout << scalar_product(v1, v2) << "\n";
    return 0;
}
\end{lstlisting}

% \section{Vektoren III}

% \begin{lstlisting}

% \end{lstlisting}

\end{document}