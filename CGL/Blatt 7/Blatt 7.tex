\documentclass[a4paper,11pt]{scrartcl} 
\usepackage{geometry} 
\geometry{left=2.5cm} \geometry{top=3cm}

\usepackage[utf8]{inputenc} 
\usepackage[ngerman]{babel} 
\usepackage[T1]{fontenc} 
\usepackage{amsmath} 
\usepackage{amssymb} 
\usepackage[onehalfspacing]{setspace} 
\usepackage{graphicx} 
\usepackage{epstopdf} 
\usepackage{csquotes} 
\usepackage{array} 
\usepackage{upgreek} 
\usepackage{float} 
\usepackage{tikz} 
\usepackage[font=small]{caption}
\usepackage[backend=biber, style=chem-angew]{biblatex} 
\addbibresource{Blatt 7.bib} 
\usepackage{tabularx, booktabs, multirow} 
\usepackage{listings}
\usepackage{chemgreek}
\usepackage{chemformula}
\captionsetup{format=plain}
%\usepackage{hyperref}
\usepackage[hidelinks]{hyperref}
\usepackage{siunitx}
\sisetup{detect-weight=true, detect-family=true,locale=DE,range-phrase={\,bis\,},list-final-separator ={\,\linebreak[0] \text{und}\,},separate-uncertainty=true,per-mode = symbol-or-fraction}

\parindent0pt %Kein Einzug am Anfang von Absätzen
\sloppy %Besserer Blocksatz
%\renewcaptionname{ngerman}{\figurename}{Abb.} 
%\renewcaptionname{ngerman}{\tablename}{Tab.} 
\setkomafont{section}{\normalsize}

\lstset{
    language=Python,
    numbers=left,
    numberstyle=\tiny\color{gray},
    numbersep=8pt,
    stepnumber=1,
    frame=single,
    tabsize=4,
    showstringspaces=false,
    breaklines=true,
    keywordstyle=\color{blue}\bfseries,
    stringstyle=\color{orange},
    commentstyle=\color{green!50!black},
    basicstyle=\ttfamily\small,
    literate={ö}{{\"o}}1
             {ä}{{\"a}}1
             {ü}{{\"u}}1
             {ß}{{\ss}}1
}

\title{Blatt 7}
\author{Vincent Kümmerle und Elvis Gnaglo}
\date{\today}

\begin{document}

\maketitle

\section{Zotero}
Machinelles Lernen wird verwendet, um Muster in Datensammlungen herauszufinden. \cite{quantum}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{Quantum.png}
    \caption{Zeitschriftenartikel über Quantum Machine Learning in der Zotero-Bibliothek.}
    \label{Quantum}
\end{figure}
Das Buch “Experimentalphysik 1” von Wolfgang Demtröder erklärt die Grundlagen der Mechanik und Wärmelehre. \cite{fisiks}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{fisiks.jpg}
    \caption{Buch über die Mechanik und Wärmelehre in der Physik.}
    \label{Fisiks}
\end{figure}

\section{List Comprehension}
\begin{lstlisting}
import random
import matplotlib.pyplot as plt
import math

def generate_random_point_in_square(length):
    """
    Generate a random point in a square of a given side length centered around the origin with the sides aligned with x- and y-axis.
    """
    return tuple([length*random.uniform(-0.5, 0.5), length*random.uniform(-0.5, 0.5)])

def distance(p1, p2):
    """
    Measures the Euclidean distance between the points p1 and p2 in 2D.
    """
    # Berechnung des euklidischen Abstands: wurzel((x2-x1)^2 + (y2-y1)^2)
    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

def point_in_circle(p, center=(0,0), radius=1.0):
    """
    Checks if the provided point p lies in a circle of a given radius around the provided center.
    """
    # Ein Punkt liegt im Kreis, wenn sein Abstand zum Mittelpunkt kleiner oder gleich dem Radius ist.
    return distance(p, center) <= radius


# TODO: generate a list of 10000 random points in a square of side length 2.0 using generate_random_point_in_square and list comprehension
# Wir nutzen _ als Laufvariable, da wir den Index nicht benötigen.
full_list_of_points = [generate_random_point_in_square(2.0) for _ in range(10000)]

# TODO: generate a list of those points in full_list_of_points that are within a radius of 1.0 of the origin (again using list comprehension)
# Wir filtern die Liste basierend auf der Bedingung point_in_circle
filtered_list_of_points = [p for p in full_list_of_points if point_in_circle(p, center=(0,0), radius=1.0)]

# TODO: print the ratio of the number of points in filtered_list_of_points to the total number of generated points
ratio = len(filtered_list_of_points) / len(full_list_of_points)
print(f"Verhältnis (Punkte im Kreis / Gesamt): {ratio}")
print(f"Annäherung an Pi (Verhältnis * 4): {ratio * 4}") 
# Erklärung: Fläche Kreis / Fläche Quadrat = (pi*r^2) / (2r)^2 = pi/4. Daher ist das Verhältnis ca. pi/4.

# TODO: Generate separate lists of the x- and y-values of full_list_of_points and filtered_list_of_points
# x-Werte sind am Index 0, y-Werte am Index 1 jedes Tupels
x_values_full = [p[0] for p in full_list_of_points]
y_values_full = [p[1] for p in full_list_of_points]

x_values_filtered = [p[0] for p in filtered_list_of_points]
y_values_filtered = [p[1] for p in filtered_list_of_points]

# Plotten
plt.figure(figsize=(6, 6)) # Quadratische Darstellung für korrekte Proportionen
plt.scatter(x_values_full, y_values_full, s=1, label='Außerhalb', color='blue')
plt.scatter(x_values_filtered, y_values_filtered, s=1, label='Innerhalb', color='red')
plt.legend(loc='upper right')
plt.title(f'Monte Carlo Simulation (Verhältnis = {ratio})')
plt.axis('equal') # Wichtig, damit der Kreis rund und nicht verzerrt aussieht
plt.show()
\end{lstlisting}

\section{Dateien lesen und Daten plotten}
\begin{lstlisting}

\end{lstlisting}
\printbibliography[title={Literaturverzeichnis}]

\end{document}