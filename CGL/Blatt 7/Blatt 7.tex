\documentclass[a4paper,11pt]{scrartcl} 
\usepackage{geometry} 
\geometry{left=2.5cm} \geometry{top=3cm}

\usepackage[utf8]{inputenc} 
\usepackage[ngerman]{babel} 
\usepackage[T1]{fontenc} 
\usepackage{amsmath} 
\usepackage{amssymb} 
\usepackage[onehalfspacing]{setspace} 
\usepackage{graphicx} 
\usepackage{epstopdf} 
\usepackage{csquotes} 
\usepackage{array} 
\usepackage{upgreek} 
\usepackage{float} 
\usepackage{tikz} 
\usepackage[font=small]{caption}
\usepackage[backend=biber, style=chem-angew]{biblatex} 
\addbibresource{Blatt 7.bib} 
\usepackage{tabularx, booktabs, multirow} 
\usepackage{listings}
\usepackage{chemgreek}
\usepackage{chemformula}
\captionsetup{format=plain}
%\usepackage{hyperref}
\usepackage[hidelinks]{hyperref}
\usepackage{siunitx}
\sisetup{detect-weight=true, detect-family=true,locale=DE,range-phrase={\,bis\,},list-final-separator ={\,\linebreak[0] \text{und}\,},separate-uncertainty=true,per-mode = symbol-or-fraction}

\parindent0pt %Kein Einzug am Anfang von Absätzen
\sloppy %Besserer Blocksatz
%\renewcaptionname{ngerman}{\figurename}{Abb.} 
%\renewcaptionname{ngerman}{\tablename}{Tab.} 
\setkomafont{section}{\normalsize}

\lstset{
    language=Python,
    numbers=left,
    numberstyle=\tiny\color{gray},
    numbersep=8pt,
    stepnumber=1,
    frame=single,
    tabsize=4,
    showstringspaces=false,
    breaklines=true,
    keywordstyle=\color{blue}\bfseries,
    stringstyle=\color{orange},
    commentstyle=\color{green!50!black},
    basicstyle=\ttfamily\small,
    literate={ö}{{\"o}}1
             {ä}{{\"a}}1
             {ü}{{\"u}}1
             {ß}{{\ss}}1
}

\title{Blatt 7}
\author{Vincent Kümmerle und Elvis Gnaglo}
\date{\today}

\begin{document}

\maketitle

\section{Zotero}
Machinelles Lernen wird verwendet, um Muster in Datensammlungen herauszufinden. \cite{quantum}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{Quantum.png}
    \caption{Zeitschriftenartikel über Quantum Machine Learning in der Zotero-Bibliothek.}
    \label{Quantum}
\end{figure}
Das Buch “Experimentalphysik 1” von Wolfgang Demtröder erklärt die Grundlagen der Mechanik und Wärmelehre. \cite{fisiks}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{fisiks.jpg}
    \caption{Buch über die Mechanik und Wärmelehre in der Physik.}
    \label{Fisiks}
\end{figure}

\section{List Comprehension}
\begin{lstlisting}
import random
import matplotlib.pyplot as plt
import math

def generate_random_point_in_square(length):
    """
    Generate a random point in a square of a given side length centered around the origin with the sides aligned with x- and y-axis.
    """
    return tuple([length*random.uniform(-0.5, 0.5), length*random.uniform(-0.5, 0.5)])

def distance(p1, p2):
    """
    Measures the Euclidean distance between the points p1 and p2 in 2D.
    """
    # TODO: wurzel((x2-x1)^2 + (y2-y1)^2)
    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

def point_in_circle(p, center=(0,0), radius=1.0):
    """
    Checks if the provided point p lies in a circle of a given radius around the provided center.
    """
    # TODO: Abstand zum Mittelpunkt kleiner/gleich dem Radius
    return distance(p, center) <= radius


# TODO: generate a list of 10000 random points in a square of side length 2.0 using generate_random_point_in_square and list comprehension
# Liste erzeugen mit _ als Laufvariable, kein Index nötig
full_list_of_points = [generate_random_point_in_square(2.0) for _ in range(10000)]

# TODO: generate a list of those points in full_list_of_points that are within a radius of 1.0 of the origin (again using list comprehension)
# Liste filtern basierend auf der Bedingung point_in_circle
filtered_list_of_points = [p for p in full_list_of_points if point_in_circle(p, center=(0,0), radius=1.0)]

# TODO: print the ratio of the number of points in filtered_list_of_points to the total number of generated points
ratio = len(filtered_list_of_points) / len(full_list_of_points)
print(f"Verhältnis (Punkte im Kreis / alle Punkte): {ratio}")
print(f"Annäherung an Pi (Verhältnis * 4): {ratio * 4}") 
# Verhältnis Punkte im Kreis (in gefilterter Liste) / alle Punkte = Fläche Kreis / Fläche Quadrat = (pi*r^2) / (2r)^2 = pi/4
# Somit konvergiert es für n gegen Unendlich gegen pi/4.

# TODO: Generate separate lists of the x- and y-values of full_list_of_points and filtered_list_of_points
# x-Werte sind am Index 0, y-Werte am Index 1 jedes Tupels
x_values_full = [p[0] for p in full_list_of_points]
y_values_full = [p[1] for p in full_list_of_points]

x_values_filtered = [p[0] for p in filtered_list_of_points]
y_values_filtered = [p[1] for p in filtered_list_of_points]

# Plotten
plt.figure(figsize=(6, 6)) # Quadratische Darstellung für korrekte Proportionen
plt.scatter(x_values_full, y_values_full, s=1, label='außerhalb', color='blue')
plt.scatter(x_values_filtered, y_values_filtered, s=1, label='innerhalb', color='red')
plt.legend(loc='upper right')
plt.title(f'Monte Carlo Simulation (Verhältnis = {ratio})')
plt.axis('equal') # damit der Kreis nicht verzerrt aussieht
plt.show()
\end{lstlisting}
% Monte-Carlo: Input = Zufallszahlen, Ergebnis = Monte-Carlo-Simulation
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{Monte.png}
    \caption{Monte Carlo Simulation}
    \label{Monte}
\end{figure}
\newpage
\section{Dateien lesen und Daten plotten}
\begin{lstlisting}
import matplotlib.pyplot as plt
import os

dateiname = r"C:\Studium\5. Semester\AC II lab\Protokolle\CGL\Blatt 7\messdaten.txt"
x_werte = []
y_werte = []

# 1. Datei öffnen und Schleife über Zeilen
try:
    with open(dateiname, 'r') as datei:
        print(f"Verarbeite Daten aus '{dateiname}'...")
        
        for zeilennummer, zeile in enumerate(datei, 1):
            
            # 2. .strip() verwenden
            bereinigte_zeile = zeile.strip()
            
            # 3. Filtern von leeren Zeilen und Kommentaren
            if not bereinigte_zeile or bereinigte_zeile.startswith('#'):
                # Ignoriere auch Zeilen, die mit '#' (Kommentar) beginnen
                continue
            
            # 4. Sonst Zeile ausgeben und Werte extrahieren
            print(f"Verarbeite: '{bereinigte_zeile}'")
            # Teile die bereinigte_zeile in Einzelteile auf
            teile = bereinigte_zeile.split() 
            
            if len(teile) == 2:
                try:
                    # Wandel die Teile in Gleitkommazahlen um
                    x = float(teile[0])
                    y = float(teile[1])
                    
                    # Speicher die Werte in den Listen x_werte und y_werte
                    x_werte.append(x)
                    y_werte.append(y)
                except ValueError:
                    print(f"Warnung in Zeile {zeilennummer}: Konnte Werte nicht in Zahlen umwandeln: '{bereinigte_zeile}'")
            else:
                print(f"Warnung in Zeile {zeilennummer}: Unerwartetes Format (erwarte 2 Werte): '{bereinigte_zeile}'")

except FileNotFoundError:
    print(f"Fehler: Die Datei '{dateiname}' wurde nicht gefunden.")

# 5. Am Ende alle x-y Werte plotten
if x_werte:
    print(f"Erfolgreich {len(x_werte)} Datenpunkte gesammelt. Erstelle Plot.")
    
    plt.figure(figsize=(10, 6)) 
    folder = r'C:\Studium\5. Semester\AC II lab\Protokolle\CGL\Blatt 7'
    # Verwenden Sie plt.scatter() um x_werte gegen y_werte zu plotten
    plt.scatter(x_werte, y_werte, color='red', marker='x', label='Messpunkte')
    
    plt.xlabel('X-Koordinate')
    plt.ylabel('Y-Koordinate')
    
    plt.title('Messdaten aus Datei')
    plt.xlabel('X-Koordinate')
    plt.ylabel('Y-Koordinate')
    plt.grid(True)
    plt.savefig(os.path.join(folder, 'messdaten_plot.pdf'))
    plt.show()
else:
    print("Keine gültigen Daten zum Plotten gefunden.")
\end{lstlisting}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{messdaten_plot.pdf}
    \caption{Plot der Messdaten}
    \label{Data}
\end{figure}

\printbibliography[title={Literaturverzeichnis}]

\end{document}